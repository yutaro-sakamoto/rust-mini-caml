use crate::ast::Exp;
use crate::id::gen_tmp;
use crate::typedef::Type;
use std::vec;
grammar;

pub Exp: Box<Exp> = {
    "let" <var:IDENT> "=" <e1:Exp> "in" <e2:Exp>
        => Box::new(Exp::Let((var, Type::Var(None)), e1, e2)),
    SemicolonExp
};

SemicolonExp: Box<Exp> = {
    <l:SemicolonExp> ";" <r:IfExp>
        => Box::new(Exp::Let((gen_tmp(Type::Unit), Type::Unit), l, r)),
    IfExp
}

IfExp: Box<Exp> = {
    "if" <TupleExp> "then" <TupleExp> "else" <TupleExp> => Box::new(Exp::If(<>)),
    TupleExp
}

TupleExp: Box<Exp> = {
    <Elems> => Box::new(Exp::Tuple(<>)),
    CompExp
};

Elems: Vec<Box<Exp>> = {
    <CompExp> "," <CompExp> => vec![<>],
    <mut v:Elems> "," <e:CompExp> => {v.push(e); v},
}

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Exp::Op(<>)),
    NextTier
};

CompExp: Box<Exp> = {
    <AddSubExp> "=" <AddSubExp> => Box::new(Exp::Eq(<>)),
    <AddSubExp> "<=" <AddSubExp> => Box::new(Exp::LE(<>)),
    <l:AddSubExp> ">=" <r:AddSubExp> => Box::new(Exp::LE(r, l)),
    <l:AddSubExp> "<" <r:AddSubExp> => Box::new(Exp::Not(Box::new(Exp::LE(r, l)))),
    <l:AddSubExp> ">" <r:AddSubExp> => Box::new(Exp::Not(Box::new(Exp::LE(l, r)))),
    <l:AddSubExp> "<>" <r:AddSubExp> => Box::new(Exp::Not(Box::new(Exp::Eq(l, r)))),
    AddSubExp
}

AddSubExp: Box<Exp> = {
    <MulDivExp> "+" <MulDivExp> => Box::new(Exp::Add(<>)),
    <MulDivExp> "-" <MulDivExp> => Box::new(Exp::Sub(<>)),
    <MulDivExp> "+." <MulDivExp> => Box::new(Exp::FAdd(<>)),
    <MulDivExp> "-." <MulDivExp> => Box::new(Exp::FSub(<>)),
    MulDivExp
}

MulDivExp: Box<Exp> = {
    <UnaryExp> "*." <UnaryExp> => Box::new(Exp::FMul(<>)),
    <UnaryExp> "/." <UnaryExp> => Box::new(Exp::FDiv(<>)),
    UnaryExp
}

UnaryExp: Box<Exp> = {
    "-" <v:AppExp> => match &(*v) {
        Exp::Float(f) => Box::new(Exp::Float(-f)),
        e => Box::new(Exp::Neg(v))
    },
    AppExp
}

AppExp: Box<Exp> = {
    SimpleExp ActualArgs => Box::new(Exp::App(<>)),
    "Array.create" <SimpleExp> <SimpleExp> => Box::new(Exp::Array(<>)),
    SimpleExp
}

ActualArgs: Vec<Box<Exp>> = {
    SimpleExp => vec![<>],
    <mut v:ActualArgs> <e:SimpleExp> => {v.push(e); v}
}

IDENT: String = {
    r"[a-zA-Z_][0-9a-zA-Z_]*" => <>.to_string()
}

SimpleExp: Box<Exp> = {
    "(" <Exp> ")" => <>,
    "(" ")" => Box::new(Exp::Unit),
    "true" => Box::new(Exp::Bool(true)),
    "false" => Box::new(Exp::Bool(false)),
    r"[0-9]+" => Box::new(Exp::Int(<>.parse().unwrap())),
    r"[0-9]+\.[0-9]*" => Box::new(Exp::Float(<>.parse().unwrap())),
    IDENT => Box::new(Exp::Var(<>)),
    <SimpleExp> "." "(" <Exp> ")" => Box::new(Exp::Get(<>)),
}